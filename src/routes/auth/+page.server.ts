// src/routes/api/auth/login/+server.ts
import prisma from '$lib/server/prisma';
import { fail } from '@sveltejs/kit';
import bcrypt from 'bcrypt';
import type { Actions } from '@sveltejs/kit';

const SESSION_COOKIE_NAME = 'sessionId';
const SESSION_DURATION_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
const SALT_ROUNDS = 10;

/*
export const actions = {
	default: async (event) => {
	login: async (event) => {
		// TODO log the user in
	},
	register: async (event) => {
		// TODO register the user
	}
} satisfies Actions;
*/

export const actions = {
  login: async ({ request, cookies }) => {
    try {
      // Change from request.json() to request.formData()
      const formData = await request.formData();
      const email = formData.get('email') as string | null;
      const password = formData.get('password') as string | null;

      if (!email || typeof email !== 'string') {
        // Consider sending a more specific error if needed, but this is okay.
        return fail(400, {error: 'Email is required and must be a valid string.'});
      }
      if (!password || typeof password !== 'string') {
        return fail(400, {error:'Password is required and must be a valid string.'});
      }

      const user = await prisma.user.findUnique({
        where: { email: email.toLowerCase() },
      });

      if (!user) {
        // Generic message for security (doesn't reveal if email exists)
        return fail(401, {error: 'Invalid email or password.'});
      }

      const passwordMatch = await bcrypt.compare(password, user.password);
      if (!passwordMatch) {
        return fail(401, {error: 'Invalid email or password.'});
      }

      // The session ID will be generated by Prisma (e.g., CUID)
      const expiresAt = new Date(Date.now() + SESSION_DURATION_MS);
      const newSession = await prisma.session.create({
        data: {
          userId: user.id,
          expiresAt,
        },
      });

      cookies.set(SESSION_COOKIE_NAME, newSession.id, {
        path: '/',
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production', // Ensures cookie is only sent over HTTPS in production
        sameSite: 'lax',
        maxAge: SESSION_DURATION_MS / 1000, // maxAge is in seconds
      });

      const { password: _, ...userWithoutPassword } = user;

      return {success: true, message: 'Login successful', user: userWithoutPassword };

    } catch (e: any) {
      console.error('Login error:', e);
      // If it's a SvelteKit error thrown by `error()`, re-throw it
      if (e && typeof e.status === 'number' && e.body && typeof e.body.message === 'string') {
          return fail(e.status, e.body.message);
      }
      // For any other unexpected errors
      return fail(500, {error: 'Failed to log in due to a server error. Please try again later.'});
    }
  },
  register: async ({ request }) => {
    try {
      // Change from request.json() to request.formData()
      const formData = await request.formData();
      const email = formData.get('email') as string | null;
      const password = formData.get('password') as string | null;
      const name = formData.get('name') as string | null; // This will be an empty string if submitted empty, or null if not present
  
      // Basic validation
      if (!email || typeof email !== 'string' || !/^\S+@\S+\.\S+$/.test(email)) {
        return fail(400, {error: 'A valid email is required.'});
      }
      if (!password || typeof password !== 'string' || password.length < 8) {
        return fail(400, {error: 'Password must be at least 8 characters long.'});
      }


      if (name && typeof name !== 'string') { // This case is unlikely with standard form data for 'name'
          return fail(400, {error:'Name, if provided, must be a valid string.'});
      }
  
  
      const existingUser = await prisma.user.findUnique({
        where: { email: email.toLowerCase() },
      });
  
      if (existingUser) {
        return fail(409, {error:  'User with this email already exists.'});
      }
  
      const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);
  
      const user = await prisma.user.create({
        data: {
          email: email.toLowerCase(),
          password: hashedPassword,
          // Handle name: if it's an empty string from the form and you want to store null, convert it.
          name: name && name.trim() !== '' ? name.trim() : null,
          isAdmin: false // Defaulting isAdmin to false
        }
      });
  
      // Remove password from user obj
      const { password: _, ...userWithoutPassword } = user;
      return {success: true, user: userWithoutPassword };

    } catch (e: any) {
      console.error('Registration error:', e);
      if (e.status && e.body && typeof e.body.message === 'string') {
          // This re-throws SvelteKit errors, which is good
          return fail(e.status, e.body.message);
      }
      // For other types of errors, throw a generic 500
      return fail(500, {error: 'Failed to register user. Please try again later.'});
    }
  },
  logout: async ({ cookies }) => {
    try {
      const sessionId = cookies.get(SESSION_COOKIE_NAME);
  
      if (sessionId) {
        try {
          await prisma.session.delete({
            where: { id: sessionId },
          });
        } catch (dbError: any) {
          if (dbError.code === 'P2025') { // Prisma's "Record to delete does not exist."
              console.warn(`Logout: Session ${sessionId} not found in DB, likely already deleted or invalid.`);
          } else {
              console.error(`Logout: Error deleting session ${sessionId} from DB:`, dbError.message);
          }
        }
  
        cookies.delete(SESSION_COOKIE_NAME, { path: '/' });
      }
  
      return {success: true, message: 'Logout successful' };
    } catch (e: any) {
      console.error('Logout error:', e);
      if (e.status && e.body && typeof e.body.message === 'string') {
          return fail(e.status, e.body.message);
      }
      return fail(500, {error:'An error occurred during logout.'});
    }
  }
  
} satisfies Actions ;